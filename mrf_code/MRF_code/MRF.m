%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MRF.m
% Authors: D.J. Fenn and J.P. Onnela
% Version 0.1: April 2012
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MRF.m calculates the mesoscopic response functions (MRFs) for a single
% network or group of networks
% Source: http://jponnela.com
%
% MRF.m uses the procedure described in the article "Taxonomies of networks
% from community structure", Onnela et al., Physical Review E, XXXXX.
%
% We calculate MRFs for a set of networks stored in a directory named
% "adj_dir". The networks should be stored as NxN matrices in .mat files,
% where N is the number of nodes in the network. The MRF procedure is
% designed for undirected networks, so we symmetrize the adjaceny matrices
% for any directed networks.
%
% For each network, we detect communities at multiple resolutions using the
% Potts method of Reichardt and Bornholdt (2006). We minimize the energy in
% the Potts Hamiltonian using the Louvain method of Blondel et al. (2008).
% MRF.m finds the communities by calling three programs. These
% files are generated by a modified version of the C++ implementation of
% the Louvain method written by E. Lefebvre and adapted by J.-L.
% Guillaume. The original version of the code is available at
% http://www.lambiotte.be/codes.html.
%
% At each resolution, we find the number of communities and the energy and
% entropy of the network partition. We then normalize these quantities and
% construct the MRFs.
%
% By default, MRF.m plots the MRFs for all of the networks in "adj_dir". In
% addition, it creates a folder "MRF_stats" and saves the files
% "MRF_curves.mat" and "MRF_distances,mat" in this folder. The former .mat
% file contains data for the MRF curves for all of the networks in
% "adj_dir"; the latter file stores the pair-wise distances between the MRFs.
%
% Further details are available in the file MRF_readme.txt.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function MRF

% store names of all adjacency matrices in directory "adj_dir"
files = dir('adj_dir');

% remove directories from "files" so that it only includes the adjacency
% matrices in "adj_dir"
rmv = [];               
for f = 1:length(files)
    if files(f).isdir
        rmv(length(rmv)+1) = f;
    end;
end;
files(rmv) = [];

% "nl" is the no. of resolution at which we find communities. Higher
% values of nl produce smoother MRFs but at the expense of additional
% computation time
nl = 150;

nonets = length(files);     % no. of networks
xi = zeros(nl,1);           % fraction of antiferromagnetic links
H = zeros(nl,1);            %f partition energy
S = zeros(nl,1);            % partition entropy
c = zeros(nl,1);            % number of communities in partition
nets = cell(nonets,1);      % store networks names

% Matrcies to store the final MRFs for all of the networks
fullxi = linspace(0,1,nl);    % xi values to interpolate over
fullH = zeros(nonets,nl);     % interpolated H matrix
fullS = zeros(nonets,nl);     % interpolated S matrix
fullc = zeros(nonets,nl);     % interpolated c matrix

for f=1:nonets  % loop through all networks in "adj_dir"

    netname = cell(textscan(files(f).name,'%s','delimiter','.'));
    nets{f} = netname{1}{1};
    fprintf('\nCommunity detection: network %d of %d: %s',f,nonets,nets{f});

    a = load(['adj_dir/' files(f).name]);   % load adjacency matrix 
    a = struct2cell(a); a = a{1};
    a = a - diag(diag(a));                  % remove self-edges
    a = abs(a);                             % ensures all links are positive
    a = (a+a')/2;                           % symmetrize adjacency matrix
    k = sum(a);                             % node degrees
    m = sum(sum(a));                        % 2*total link weight (2m)
    nodes = length(a);                      % no. of nodes

    % create a .txt file storing the edge list for the network. This might
    % seem like a bit of a strange thing to do given that we already have
    % the adjacency matrix, but this is the input format used in the C++
    % community detection program that we call later.
    [edges(:,1),edges(:,2),edges(:,3)] = find(triu(a));
    edges(:,1) = edges(:,1) - 1;    % node numbers run from 0 to N-1
    edges(:,2) = edges(:,2) - 1;
    edges = sortrows(edges);

    % write edge list to file
    dlmwrite([nets{f} '.txt'],edges,'delimiter',' ','precision',8);
    clear edges;

    % nzap store the ratio of A_{ij}/P_{ij} for all nodes in the network.
    % We use this to determine the range of resolution to sweep over
    nzap = nonzeros(a./NGmodel(a));
    nzap(isnan(nzap))=[];
    nzap = sort(nzap);
    
    % Select nl resolutions to sweep over based on the distribution nzap.
    % Depending on the sparseness of the networks we add some resolutions
    % between 0 and min(nzap). This is because some networks can break into
    % communities at resolutions < min(nzap).
    
    % Fully-connected networks only break into communities at resolution
    % >min(nzap) so we only use resolution > min(nzap)
    if(length(nzap)==(nodes*nodes - nodes))         
        lidx = ceil(linspace(1,length(nzap),nl));
        lambda = nzap(lidx);
        clear nzap;                                         % just to save memory
        lambda(1) = lambda(1) - 2*eps(lambda(1));           % Ensure smallest resolution is less than min(nzap)
        lambda(end) = lambda(end) + 2*eps(lambda(end));     % Ensure largest resolution is greater than max(nzap)
    elseif(length(nzap)>0.9*(nodes*nodes - nodes))          % We se 5% of resolutions < min(nzap) for almost-fully-connected networks
        nsres = ceil(0.05*nl);
        lidx = ceil(linspace(1,length(nzap),nl-nsres));
        lambda = nzap(lidx);
        morel = linspace(2*eps,nzap(1),nsres);
        clear nzap;
        lambda = [morel';lambda];
        lambda(end) = lambda(end) + 2*eps(lambda(end));
    else                                                    % We set 25% of resoltions < min(nzap) for sparser networks
        nsres = ceil(0.25*nl);
        lidx = ceil(linspace(1,length(nzap),nl-nsres));
        lambda = nzap(lidx);
        morel = linspace(2*eps,nzap(1),nsres);
        clear nzap;
        lambda = [morel';lambda];
        lambda(end) = lambda(end) + 2*eps(lambda(end));
    end;
    
    % Remove files - this is important because the C++ code will append to
    % any existing files on the next resolution run
    system(['rm ' nets{f} '_temp.dat']);
    system(['rm ' nets{f} '_comms.dat']);
    % Call the C++ community detection code from the command line
    system(['./convert -i ' nets{f} '.txt -o ' nets{f} '.bin -w']);

    for i = 1:nl    % loop through resolutions
        
        %fprintf('\nResolution %d of %d',i,nl);
        % Further calls to C++ community detection code
        [em,Hres] = system(['./community ' nets{f} '.bin -l -1 -w -t ' num2str(lambda(i),20) ' > ' nets{f} '_temp.dat']);
        system(['./hierarchy ' nets{f} '_temp.dat >> ' nets{f} '_comms.dat']);
        H(i) = str2double(Hres);                                % energy of partition
        
        config = dlmread([nets{f} '_comms.dat']);
        config = config(:,2) + 1;                               % community IDs for each node in partition

        xi(i) = length(find((a - lambda(i)*NGmodel(a))<0));     % fraction of antiferromagnetic links
        H(i) = -m*(H(i) + trace(lambda(i)*((k'*k)/(m*m))));     % partition energy
        S(i) = entropy(config);                                 % partition entropy
        c(i) = max(config);                                     % no. of communities
        
    end
    
    Nc = c;                                 % Nc now stores the number of communities
    c = c/max(c);                           % c stores the normalized number of communities
    
    idx1 = find(Nc==min(Nc),1,'last');      % largest resolution for which Nc=1
    idx2 = find(Nc==max(Nc),1,'first');     % smallest resolution for which Nc=no. of nodes
    idx = idx1:idx2;                        % range of resolutions we are interested in
    
    % Caclculate effective H, S, c, and xi
    H_eff = (H(idx)-min(H(idx)))/(max(H(idx))-min(H(idx)));
    S_eff = (S(idx)-min(S(idx)))/(max(S(idx))-min(S(idx)));
    c_eff = (c(idx)-min(c(idx)))/(max(c(idx))-min(c(idx)));
    xi_eff = (xi(idx)-min(xi(idx)))/(max(xi(idx))-min(xi(idx)));
    
    % We want to calculate areas between the MRFs, so we interpolate to find the
    % values of the various statistics at the same values of xi for all networks
    uxi = unique(xi_eff);
    uH = zeros(length(uxi),1);
    uS = zeros(length(uxi),1);
    uc = zeros(length(uxi),1);
    
    % Select the maximum values of the summary statistic at each xi
    for u=1:length(uxi)
        uH(u) = max(H_eff(xi_eff==uxi(u)));
        uS(u) = max(S_eff(xi_eff==uxi(u)));
        uc(u) = max(c_eff(xi_eff==uxi(u)));
    end;
    fullH(f,:) = interp1(uxi,uH,fullxi);
    fullS(f,:) = interp1(uxi,uS,fullxi);
    fullc(f,:) = interp1(uxi,uc,fullxi);

end

%Ensure that all MRFs start at [0,0]. They might not after the above
%interpolations because the no. of communities could be >1 at xi=0
fullxi = [0,fullxi];
fullH = [zeros(nonets,1),fullH];
fullS = [zeros(nonets,1),fullS];
fullc = [zeros(nonets,1),fullc];

%--------------------------------------------------------------------------
% Calculate distances between MRFs
%--------------------------------------------------------------------------

if(nonets>1)

    dH = zeros(nonets);     % H distance matrix
    dS = zeros(nonets);     % S distance matrix
    dc = zeros(nonets);     % c distance matrix

    for i = 1:nonets  
         for j = i:nonets
            dH(i,j) = trapz(fullxi,abs(fullH(i,:)-fullH(j,:)));
            dH(j,i) = dH(i,j);
            dS(i,j) = trapz(fullxi,abs(fullS(i,:)-fullS(j,:)));
            dS(j,i) = dS(i,j);
            dc(i,j) = trapz(fullxi,abs(fullc(i,:)-fullc(j,:)));
            dc(j,i) = dc(i,j);
         end
    end;

    % Calculate principal component distances
    dists = [squareform(dH);squareform(dS);squareform(dc)]';
    [pccoefs,em,em] = princomp(dists);
    tdpc = dists*pccoefs;
    dp = squareform(tdpc(:,1));
    dp = (dp-min(min(dp)))/(max(max(dp))-min(min(dp)));
    dp = dp - diag(diag(dp));

end

%----------------------------------------------------------------------
% Plot MRFS
%----------------------------------------------------------------------

for f=1:nonets  % loop through networks
    
    figure;
    plot(fullxi,fullH(f,:),'r','LineWidth',2); hold on;
    plot(fullxi,fullS(f,:),'b','LineWidth',2);
    plot(fullxi,fullc(f,:),'g','LineWidth',2);
    xlim([0 1]); ylim([0 1]); xlabel('\xi','FontSize',16);
    set(gca,'FontSize',12); title(nets{f},'Interpreter','none');
    box on; hold off;
    
end;

%--------------------------------------------------------------------------
% Save MRFs and distance matrices to file
%--------------------------------------------------------------------------
dirname = 'MRF_stats';
if ~isdir(dirname)
    mkdir(dirname);
end;
save([dirname,'/MRF_curves.mat'],'nets','fullH','fullS','fullc','fullxi');
if(nonets>1) 
    save([dirname,'/MRF_distances.mat'],'nets','dH','dS','dc','dp');
end

end



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Function definitions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%--------------------------------------------------------------------------
% Newwman-Girvan null model
%--------------------------------------------------------------------------
function p = NGmodel(a)
    k = sum(a);
    m = (sum(k) + trace(a))/2;
    p = (k'*k)/(2*m);
end

%--------------------------------------------------------------------------
% Entropy of partition
%--------------------------------------------------------------------------
function S = entropy(sigma)

    u = unique(sigma);
    number_clusters = length(u);
    num_nodes_in_cluster = zeros(number_clusters);
    for i = 1:number_clusters
        num_nodes_in_cluster(i) = length(find(sigma==u(i)));
    end
    n = sum(num_nodes_in_cluster);

    p = num_nodes_in_cluster/n;
    S = -sum(p.*log(p));

end